
1) main :
	- init permet davoir tout d'initialise (mlx_init();, ).
	- LA MAP :
			- Je prends comme entree game et la map sous format char*✔
			- je lance la fonction pour verifier la map ! [je retire game == NULL, pave doit faire minimum 5 caractere ? (supposition bonne)]


	int				panglemin; // inutile a supp
	int				panglemax; // inutile a suppgame->c[0] (colonne de ton ecran) , g->ray->x[1] (posx?));
~~~~~~~~~~~~~~~~~~~~
	int				ph; // p_h vaut juste 53, a suppr si rien de plus important
draw_column(game, 1,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 1 2 3 4 5 6 7 8 pas a  0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game.count[0] = fd;
[1] = i puis reset !
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game.flag[0] = pour mode dans error_message
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ft_strlen(line) > 2 ???? dans mapper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 1 2 3 4 5 6 7 prit
ft_colo jai inversé en 2 1 0 pck pas compris
img.data[0] et img.data[1] SOL ET TOIT
nom 2 3 4 5 6  sprite est nord ouest sud
7 : la fenetre
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
jreserve game.c[3][4]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CELL ?? pk 64 : ca c bone
M_PI valeur de pi
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game->ray.dist[1] mal calculé
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game->cs = pix[count].type; ???

0.0174f = 1 degré en radiant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# define TO_COORD(X, Y) ((int)floor(Y) * WIDTH + (int)floor(X))

les pixels ca commence en haut a gauche

		ft_memset(game->img.data, 0, ft_strlen((const char *)game->img.data));
game->img.data[i][count_h * game->img.width[i] + count_w] = game->img.data[i][count_h * game->img.width[i] + (count_w - 1)];

Raycast :

ROWS = HEIGHT
COLS = WIDTH

posx/y la position de mon perso
dx/y direction

La distance entre moi et le mur va definir la hauteur du mur :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Le mur :	- OU EST IL PLACE dx,dy
			- Hauteur, longueur game.height[] game.width[] du mur
			- les couleurs dedans ^^

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Objectif plus tard :
			- lire une map
			- rendering

Objectif aujourd'hui :
			- mlx_loop_hook : comprendre et setup
			- render scene chez 3ami

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SETUPED:

		- Je crée une image, et je prends sa data, je la detruit en return

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		- fais ft_dist
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 dans rcx jai mit un (int)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Raycast:
	he de : hauteur a l'ecran et distance de l'ecran
	hm dm : hauteur du mure et distance du mur

	donc la hauteur percue = distance ecran * hauteurdumure/distancedumur

	[hauteurregard - hauteurpercu/2, hauteurregard - hauteurpercu/2]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
un cos positive ca signife qu'il regarde vers est nord est ou sud est soit entre [0, 90] et [270, 380(0)]
ceil(x) : entier((float)x)




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

J'ai deux ray : y => ray.[1]
				x => ray.[0]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~é

- Je peux depasser les murs de ma map :

~~~~~~~~~~~~~~~~~~~~
rcy
//	g->ray.angle[1] = (g->pangle + 0.0174 / 2.0 - count * (40 / g->img.width[7])) * 0.0174;
//	si il regarde vers la droite alors tu prends lentier au dessus sinon en dessous ?
//	if (cos(g->ray.angle[1]) > 0)
//		g->ray.x[1] = ceil((float)(g->posx) / 64) * 64;
//	else
//		g->ray.x[1] = floor((float)(g->posx) / 64) * 64;
// |(positionx - valbizarre)/sin(de l'angle)| * cos(angle) + position x

rcx
//	g->ray.angle[0] = (float)g->pangle;
	g->c[1] = 0;
//	g->ray.angle[0] = (g->pangle + 0.0174 / 2.0 - count * (40 / g->img.width[7])) * 0.0174;
//	if (cos(g->ray.angle[0]) == 0)
//		return ();
//	si il regarde vers la droite alors tu prends lentier au dessus sinon en dessous ?
//	if (cos(g->ray.angle[0]) > 0)
//		g->ray.x[0] = ceil((float)(g->posx) / 64) * 64;
//	else
//		g->ray.x[0] = floor((float)(g->posx) / 64) * 64;

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Je passe a travers le mur a cause de rcy ?
/!\ sprite 2
	Nord 4 Brique rcy (je vois du nord a l'est, jvois du nord a l'ouest, donc g->ray.dist[1]>g->ray.dist[0] et )
	Est 3 Bois (pas de soucis) rcx
	Ouest 5 Herbe (je vois de l'ouest a l'est) rcx
	Sud 6 Marbre rcy

Ray.ange, calcul l'angle de chaque pixel, la range de de l'ecran, je mets 40
Pour x :
		calcul du cos de l'angle donc son projeté sur x : si elle est positive tu regardes a droite, negative a gauche et nulle signifie un bug
		ray.x[0] prochain bloc en visu
		Adjacent sur l'hypthenus : donne le cos :> adjacent sur cos donne hypothenus : >


Comparaison X et Y :

				On prend le cos de l'angle // On prend son sin
				ON parse par la largeur de la map // On parse par sa longueur
				Selon l'angle ON parse par la droite ou par la gauche les cases // Selon l'angle on parse verse le haut ou vers la bas
					Positif droite donc augmente vs negatif gauche donc reduit// Positif alors on avance, donc on reduit Negatif alors on recule donc on ajoute
				 On calcul la longueur de la ligne entre nous et ce bloc
				 	y[0] : adjacent/cos(angle) = hypothenuse :> * sin(angle) :> longueur opposé :> + posy :> pose du prochain mur sur y
					x[1] : opposé/sin(angle) = hypothenuse :> * cos(angle) :> longueur aadjacent :> + posx :> pose du prochain mur sur x



/* 		if(game->flag[2] == 1 && (game->ray.dist[1] < game->ray.dist[0]) && (game->ray.flag[1] == 2))
		{
			printf("----------------------------------------------------------------- \n");
			printf("Position : X %d/%d -  Y %d/%d\n", game->posx / 64, game->mapx , game->posy / 64, game->mapy);
			printf("Pos Murcoté [0] : %f\nPos Murligne[0] : %f\n",(float)((game->ray.x[0] ) - game->posx) / 64 , (float)(game->ray.y[0] - game->posy)/64);
			printf("Pos Murcoté [1] : %f\nPos Murligne[1] : %f\n", (float)((game->ray.x[1] ) - game->posx) / 64 , (float)(game->ray.y[1] - game->posy)/64);
			printf("Pos Murcoté [0] : %d\nPos Murligne[0] : %d\n", (game->ray.x[0] )/64, (game->ray.y[0] )/64);
			printf("Pos Murcoté [1] : %d\nPos Murligne[1] : %d\n", (game->ray.x[1] ) /64 , (game->ray.y[1] )/64);
			printf("Angle :  %d° \nAngle Ecran : %f° \n", game->pangle, game->ray.angle*(1/0.0174));
 			printf("Cos Angle ecran : %f\nSin Angle ecran : %f\n", cos(game->ray.angle), sin(game->ray.angle));
			printf("Distance[0] : %f \nDistance[1] : %f \n", game->ray.dist[0] / 64, game->ray.dist[1] / 64);
			printf("Case 1 : %d/%d\n", (game->ray.x[1] + ft_signe(game->ray.x[1] - game->posx)) / 64 , (game->ray.y[1] + ft_signe(game->ray.y[1] - game->posy)) / 64);
			printf("----------------------------------------------------------------- \n\n");
		} */
