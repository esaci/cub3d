
1) main :
	- init permet davoir tout d'initialise (mlx_init();, ).
	- LA MAP :
			- Je prends comme entree game et la map sous format char*✔
			- je lance la fonction pour verifier la map ! [je retire game == NULL, pave doit faire minimum 5 caractere ? (supposition bonne)]


	int				panglemin; // inutile a supp
	int				panglemax; // inutile a suppgame->c[0] (colonne de ton ecran) , g->ray->x[1] (posx?));
~~~~~~~~~~~~~~~~~~~~
	int				ph; // p_h vaut juste 53, a suppr si rien de plus important
draw_column(game, 1,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 1 2 3 4 5 6 7 8 pas a  0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game.count[0] = fd;
[1] = i puis reset !
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game.flag[0] = pour mode dans error_message
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ft_strlen(line) > 2 ???? dans mapper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 1 2 3 4 5 6 7 prit
ft_colo jai inversé en 2 1 0 pck pas compris
img.data[0] et img.data[1] SOL ET TOIT
nom 2 3 4 5 6  sprite est nord ouest sud
7 : la fenetre
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
jreserve game.c[3][4]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CELL ?? pk 64 : ca c bone
M_PI valeur de pi
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game->ray.dist[1] mal calculé
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
game->cs = pix[count].type; ???

0.0174f = 1 degré en radiant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# define TO_COORD(X, Y) ((int)floor(Y) * WIDTH + (int)floor(X))

les pixels ca commence en haut a gauche

		ft_memset(game->img.data, 0, ft_strlen((const char *)game->img.data));
game->img.data[i][count_h * game->img.width[i] + count_w] = game->img.data[i][count_h * game->img.width[i] + (count_w - 1)];

Raycast :

ROWS = HEIGHT
COLS = WIDTH

posx/y la position de mon perso
dx/y direction

La distance entre moi et le mur va definir la hauteur du mur :

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Le mur :	- OU EST IL PLACE dx,dy
			- Hauteur, longueur game.height[] game.width[] du mur
			- les couleurs dedans ^^

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Objectif plus tard :
			- lire une map
			- rendering

Objectif aujourd'hui :
			- mlx_loop_hook : comprendre et setup
			- render scene chez 3ami

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SETUPED:

		- Je crée une image, et je prends sa data, je la detruit en return

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		- fais ft_dist
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 dans rcx jai mit un (int)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Raycast:
	he de : hauteur a l'ecran et distance de l'ecran
	hm dm : hauteur du mure et distance du mur

	donc la hauteur percue = distance ecran * hauteurdumure/distancedumur

	[hauteurregard - hauteurpercu/2, hauteurregard - hauteurpercu/2]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
un cos positive ca signife qu'il regarde vers est nord est ou sud est soit entre [0, 90] et [270, 380(0)]
ceil(x) : entier((float)x)




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

J'ai deux ray : y => ray.[1]
				x => ray.[0]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~é

- Je peux depasser les murs de ma map :

~~~~~~~~~~~~~~~~~~~~
rcy
//	g->ray.angle[1] = (g->pangle + 0.0174 / 2.0 - count * (40 / g->img.width[7])) * 0.0174;
//	si il regarde vers la droite alors tu prends lentier au dessus sinon en dessous ?
//	if (cos(g->ray.angle[1]) > 0)
//		g->ray.x[1] = ceil((float)(g->posx) / 64) * 64;
//	else
//		g->ray.x[1] = floor((float)(g->posx) / 64) * 64;
// |(positionx - valbizarre)/sin(de l'angle)| * cos(angle) + position x

rcx
//	g->ray.angle[0] = (float)g->pangle;
	g->c[1] = 0;
//	g->ray.angle[0] = (g->pangle + 0.0174 / 2.0 - count * (40 / g->img.width[7])) * 0.0174;
//	if (cos(g->ray.angle[0]) == 0)
//		return ();
//	si il regarde vers la droite alors tu prends lentier au dessus sinon en dessous ?
//	if (cos(g->ray.angle[0]) > 0)
//		g->ray.x[0] = ceil((float)(g->posx) / 64) * 64;
//	else
//		g->ray.x[0] = floor((float)(g->posx) / 64) * 64;

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Je passe a travers le mur a cause de rcy ?


/////////////////////////////////////////////////:
Info : taille d'un mur normalement : 150


//////////////////////////////////////////////////////////////////////////////////:

320 x 200 donc milieu 160x100


On recupere l'angle de rotation : game->pangle
ray.angle : angle de rotation auquel on soustrait plus le pixel est a droite plus en soustrait
